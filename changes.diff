diff --git a/SimAPR/core.py b/SimAPR/core.py
index a693c8042..523af65bd 100644
--- a/SimAPR/core.py
+++ b/SimAPR/core.py
@@ -10,6 +10,7 @@ import uuid
 import math
 
 import branch_coverage
+import field_change
 
 
 class Mode(Enum):
@@ -225,6 +226,123 @@ class CriticalBranchesUpDownManager:
       return True
     else:
       return False
+    
+    
+class CriticalFieldUpDown:
+  """
+  used for GreyBox approach
+  multiple of instances are stored in CriticalFields as the value of the dictionary, with the field name as a key.
+  saves and handle the data that are related to the fitness score of one field
+
+  Returns:
+      _type_: _description_
+  """
+  def __init__(self, fieldUpInit: float = 1., fieldDownInit: float = 1.) -> None:
+    """_summary_
+
+    Args:
+        fieldUpInit (float, optional): _description_. Defaults to 0..
+        fieldDownInit (float, optional): _description_. Defaults to 0..
+    """
+    self.fieldUpInit=fieldUpInit # a constant value. saves the initial value of the fieldUpScore.
+    self.fieldUpScore=fieldUpInit # it will be increase with some kinds of value (increasing amount depends on the update method)
+    self.fieldDownInit=fieldDownInit # a constant value. saves the initial value of the fieldDownScore.
+    self.fieldDownScore=fieldDownInit # it will be increase with some kinds of value (increasing amount depends on the update method)
+    
+  def update(self, field_difference:float):
+    """
+    Compare the original_field_last_value and the patched_field_last_value to update the scores.
+    - if original_field_last_value > patched_field_last_value then self.fieldDownScore increases.
+    - if original_field_last_value < patched_field_last_value then self.fieldUpScore increases.
+    - the amount of increasement can be modified in this source code.
+
+    Args:
+        original_field_last_value (str): _description_
+        patched_field_last_value (str): _description_
+    """
+    print('grey-box field alpha updated')
+    if field_difference<0:
+      self.fieldDownScore+=1 # increase the score with some value.
+    elif field_difference>0:
+      self.fieldUpScore+=1 # increase the score with some value.
+
+  def mode(self):
+    if self.fieldUpScore==0:
+      up_score=0.
+    else:
+      up_score=self.fieldUpScore
+    if self.fieldDownScore==0:
+      down_score=0.
+    else:
+      down_score=self.fieldDownScore
+    
+    return down_score,up_score
+
+  def select_value(self,isUp:bool) -> float: # select a value randomly from the beta distribution
+    """
+    select a value randomly from the beta distribution.
+    The distribution for selecting varies depending on the 'isUp'.
+
+    Args:
+        isUp (bool): true if the field count increases in patched one then the buggy one, otherwise false.
+
+    Returns:
+        float: _description_
+    """
+    if isUp:
+      return np.random.beta(self.fieldUpScore, self.fieldUpInit)
+    else:
+      return np.random.beta(self.fieldDownScore, self.fieldDownInit)
+    
+
+class CriticalFieldsUpDownManager:
+  """
+  This class is used not only for the critical field data but also for the field difference data of each node in the patch tree 
+  although the name of the class is still "CriticalFieldUpDownManager"
+  
+  This class has a dictionary that saves the field names as key and CriticalFieldUpDown as value.
+  It helps you to call CriticalFieldUpDown with an specific index when calling 'update' and 'select_value'.
+  this class also can be used when there are some jobs that have to deal with multiple of CriticalFieldUpDown.
+  
+  This class will be instanciated when initiaing the GlobalState and it is used for the ~~~...
+  Also it is instantiated in each PatchTreeNode. it is for ~~~
+  """
+  def __init__(self, is_this_critical_fields = False):
+    self.upDownDict:Dict[str, CriticalFieldUpDown]=dict()
+    self.is_this_critical_fields=is_this_critical_fields
+    
+  def update(self, state:'GlobalState', field_name:str, field_difference:float):
+    if field_name not in self.upDownDict:
+      self.upDownDict[field_name]=CriticalFieldUpDown()
+      if self.is_this_critical_fields:
+        state.new_critical_list.append(field_name)
+
+    self.upDownDict[field_name].update(field_difference)
+  
+  def is_empty(self):
+    return not bool(self.upDownDict)
+    
+  def select_value(self, field_name:str, isUp:bool)->float:
+    if field_name not in self.upDownDict:
+      self.upDownDict[field_name]=CriticalFieldUpDown()
+    return self.upDownDict[field_name].select_value(isUp)
+  
+  def get_isUp(self, field_name:str):
+    """
+    TODO: more description
+    IMPORTANT: it return False when up score == down score
+
+    Args:
+        field_name (str): _description_
+
+    Returns:
+        _type_: _description_
+    """
+    the_field=self.upDownDict[field_name]
+    if the_field.fieldUpScore>the_field.fieldDownScore:
+      return True
+    else:
+      return False
 
 class PatchTreeNode:
   def __init__(self):
@@ -246,6 +364,10 @@ class PatchTreeNode:
     self.coverage_info=PassFail()
     self.patches_template_type:List[str] = []
     self.critical_branch_up_down_manager:CriticalBranchesUpDownManager=CriticalBranchesUpDownManager()
+    
+    # greybox field change things
+    self.change_info=PassFail()
+    self.critical_field_up_down_manager:CriticalFieldsUpDownManager=CriticalFieldsUpDownManager()
 
 class LocationNode(PatchTreeNode):
   def __init__(self):
@@ -441,11 +563,13 @@ class EnvGenerator:
     if state.mode==Mode.greybox and (instrument or state.only_get_test_time_data_mode):
       new_env['GREYBOX_BRANCH']='1'
       new_env['GREYBOX_RESULT']=f'/tmp/{state.d4j_buggy_project}-{test.replace("::","#")}.txt'
+      new_env['GREYBOX_FIELD_RESULT']=f'/tmp/field/{state.d4j_buggy_project}-{test.replace("::","#")}.txt'
       new_env['GREYBOX_INSTR_ROOT']=state.instrumenter_classpath
       new_env['CLASSPATH']=state.instrumenter_classpath
     else:
       new_env['GREYBOX_BRANCH']='0'
       new_env['CLASSPATH']=state.instrumenter_classpath
+      
     return new_env
   
   @staticmethod
@@ -462,11 +586,13 @@ class EnvGenerator:
     if state.mode==Mode.greybox and (instrument or state.only_get_test_time_data_mode):
       new_env['GREYBOX_BRANCH']='1'
       new_env['GREYBOX_RESULT']=f'/tmp/{state.d4j_buggy_project}-{test.replace("::","#")}.txt'
+      new_env['GREYBOX_FIELD_RESULT']=f'/tmp/field/{state.d4j_buggy_project}-{test.replace("::","#")}.txt'
       new_env['GREYBOX_INSTR_ROOT']=state.instrumenter_classpath
       new_env['CLASSPATH']=state.instrumenter_classpath
     else:
       new_env['GREYBOX_BRANCH']='0'
       new_env['CLASSPATH']=state.instrumenter_classpath
+      
     return new_env
   
   @staticmethod
@@ -474,6 +600,7 @@ class EnvGenerator:
     new_env["SIMAPR_TEST"] = "ALL"
     new_env['CLASSPATH']=state.instrumenter_classpath
     new_env['GREYBOX_BRANCH']='0'
+    new_env['GREYBOX_FIELD']='0'
     return new_env
 
 class TbarPatchInfo:
@@ -521,6 +648,22 @@ class TbarPatchInfo:
     self.line_info.critical_branch_up_down_manager.update(state,branch_index, branch_difference)
     self.func_info.critical_branch_up_down_manager.update(state,branch_index, branch_difference)
     self.file_info.critical_branch_up_down_manager.update(state,branch_index, branch_difference)
+  
+  def update_field_result(self, state:'GlobalState', field_name:str, field_difference:float) -> None:
+    """
+    Used for the GreyBox Approach.
+    
+    This function updates the CriticalFieldUpDown in every node in path to the patch
+
+    Args:
+        field_name (str): _description_
+        field_difference (float): _description_
+    """
+    self.tbar_case_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.tbar_type_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.line_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.func_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.file_info.critical_field_up_down_manager.update(state,field_name, field_difference)
     
   def remove_patch(self, state: 'GlobalState') -> None:
     """
@@ -633,6 +776,21 @@ class RecoderPatchInfo:
     self.line_info.critical_branch_up_down_manager.update(state,branch_index, branch_difference)
     self.func_info.critical_branch_up_down_manager.update(state,branch_index, branch_difference)
     self.file_info.critical_branch_up_down_manager.update(state,branch_index, branch_difference)
+  
+  def update_field_result(self, state:'GlobalState', field_name:str, field_difference:float) -> None:
+    """
+    Used for the GreyBox Approach.
+    
+    This function updates the CriticalFieldUpDown in every node in path to the patch
+
+    Args:
+        field_name (str): _description_
+        field_difference (float): _description_
+    """
+    self.recoder_case_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.line_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.func_info.critical_field_up_down_manager.update(state,field_name, field_difference)
+    self.file_info.critical_field_up_down_manager.update(state,field_name, field_difference)
 
   def remove_patch(self, state: 'GlobalState') -> None:
     if self.recoder_case_info.location not in self.line_info.recoder_case_info_map:
@@ -857,6 +1015,13 @@ class GlobalState(metaclass=SingletonMeta):
     self.only_get_test_time_data_mode = False
     self.test_time_data_location = ""
     
+    # Added in greybox-APR field change
+    self.field_output=''
+    self.use_field=False
+    self.original_field_change:Dict[str,field_change.FieldChange]=dict()  # [test, change]
+    self.hq_patch_diff_change_set:Set[field_change.FieldChange]=set()  # Every (change_patch - change_original) change of HQ patches
+    self.critical_field_up_down_manager:CriticalFieldsUpDownManager = None
+    
 def patch_ochiai_calculator(state:GlobalState, str):
   valid_branches=0
   total = 0.
diff --git a/SimAPR/field_change.py b/SimAPR/field_change.py
new file mode 100644
index 000000000..3fa875066
--- /dev/null
+++ b/SimAPR/field_change.py
@@ -0,0 +1,70 @@
+from logging import Logger
+from typing import Dict, Tuple, List
+
+def toNumeric(v: str):
+    if v.lower() == 'true':
+        return 1
+    if v.lower() == 'false':
+        return 0
+    return float(v)
+
+class FieldChange:
+    def __init__(self):
+        self.field_change:Dict[str,float]=dict() # key: field_name, value: history
+
+    def append(self, field:str, value):
+        if field in self.field_change:
+            self.field_change[field].append(value)
+        else:
+            self.field_change[field]=[value]
+    
+    def diff(self,other:'FieldChange')->List[Tuple[str,float]]:
+        diff:List[Tuple[str,float]]=[]
+        for field in self.field_change:
+            if field in other.field_change:
+                if self.field_change[field]!=other.field_change[field]:
+                    diff.append((field,self.field_change[field]-other.field_change[field]))
+            else:
+                diff.append((field,self.field_change[field]))
+        
+        for field in other.field_change:
+            if field not in self.field_change:
+                diff.append((field,-other.field_change[field]))
+        return diff
+    
+def parse_change(logger:Logger, change_file: str):
+    """
+    :param change_file: field change file
+    :return: field change vector
+    """
+    change=FieldChange()
+    logger.info(f"i want to open {change_file}")
+    
+    # try:
+    #     root = ET.parse(change_file)
+    #     fieldTags = root.findall("field")
+    #     for fieldTag in fieldTags:
+    #         id = fieldTag.get("id")
+    #         history = List()
+    #         for value in fieldTag:
+    #             if (value.text != None):
+    #                 history.append(int(value.text))
+    #         change.field_change[id] = history
+    # except:
+    #     logger.warning(f"Error parsing field change file: {change_file}")
+    
+    with open(change_file, 'r') as f:
+        for line in f:
+            try:
+                field_name,value = line.strip().split(":")
+                change.field_change[field_name] = toNumeric(value)
+            except:
+                logger.warning(f"Error parsing field change: {line.strip()}")
+        
+    return change
+
+# def is_good_patch(cov_patch_diff:Set[Tuple[int,int]],cov_orig_diff:Set[Tuple[int,int]])->bool:
+#     for cov_element in cov_patch_diff:
+#         if cov_element in cov_orig_diff:
+#             return True
+#     return False
\ No newline at end of file
diff --git a/SimAPR/result_handler.py b/SimAPR/result_handler.py
index 8b699ab2b..032c3ddcb 100644
--- a/SimAPR/result_handler.py
+++ b/SimAPR/result_handler.py
@@ -354,3 +354,84 @@ def update_result_branch(state:GlobalState,selected_patch:Union[TbarPatchInfo,Re
                           f"each_result[testName]: {each_result[testName]}, "
                           f"testName in branch_coverage: {testName in branch_coverage}, "
                           f"testName in state.original_branch_cov: {testName in state.original_branch_cov}")
+
+def update_result_field(state:GlobalState,selected_patch:Union[TbarPatchInfo,RecoderPatchInfo],field_change:Dict[str,field_change.FieldChange],
+                         is_compilable:bool,each_result:Dict[str,bool],pass_result:bool):
+  """
+  This function is used for the GreyBox Approach of the Casino.
+  It deals with the field data of patched program runs when each test has end.
+  This function basically handle the every patch testing result that has to be done for the GreyBox approach. 
+  
+  This function does the jobs below.
+  - Finds critical field.
+    - For each failing test, if the test for patched program is passed, the fields that has different count to that of buggy program is now critical fields
+  - Compare the first different value of field changes between the buggy(=original) program and the patched one, and update the field data in GlobalState and each PatchTreeNode that is ancester of patch.
+    - Critical fields are saved as state.critical_fields:Dict[str, Set[Tuple[int,int]]], where the tuple[0] is the field name and tuple[1] is difference. 
+    - examples: 
+      for some field[1] and test_A, if field[1] has changes of [10, 11, 12] in patched version and [10, 11, 15] in original buggy version, then (1, -3) becomes an element of critical_fields[test_A].
+      for some field[0] and test_B, if field[0] has changes of [24, 10, -5] in patched version and [24, 3, 100] in original buggy version, then (0, 7) becomes an element of critical_fields[test_B].
+  - However, if the patch is not compilable (is_compilable == false), this function does nothing.
+  
+  This function is composed of following parts.
+  - A loop for comparing the fields of the buggy program and the patched program to find out the critical fields and save the field informations.
+
+  Args:
+      state (GlobalState): The global state. It is a object that saves every information of total run of SimAPR and is used just like a singleton.
+      selected_patch (Union[TbarPatchInfo,RecoderPatchInfo]): Patch information. It varies depending on the 
+      field_change (Dict[str,field_change.FieldCoverage]): field
+      is_compilable (bool): whether the patched program is compilable.
+      each_result (Dict[str,bool]): The test results of each test on the patched program. Key(:str) is the name of a test, and value(:bool) is the result (true if the test is passedm otherwise false).
+      pass_result (bool): whether the all tests has passed. It has to be true when every value of 'each_result(:Dict[str,bool])' is true, otherwise it is false.
+  """
+  
+  if not is_compilable:
+    return
+  
+  state.logger.debug(f"update_result_field is called, d4j_negative_test length: {len(state.d4j_negative_test)}")
+  
+  if isinstance(selected_patch,TbarPatchInfo):
+    cur_node=selected_patch.tbar_case_info
+  elif isinstance(selected_patch,RecoderPatchInfo):
+    cur_node=selected_patch.recoder_case_info
+  else:
+    raise RuntimeError(f'Invalid patch type: {type(selected_patch)}, it should be TbarPatchInfo or RecoderPatchInfo')
+
+  while not isinstance(cur_node,GlobalState):
+    # Update critical fields in each nodes
+    if isinstance(cur_node,FileInfo):
+      cur_node=state
+    else:
+      cur_node=cur_node.parent
+    critical_field_list:List[str] = list(cur_node.critical_field_up_down_manager.upDownDict.keys())
+
+    if state.optimized_instrumentation and state.use_simulation_mode:
+      for testName in state.d4j_negative_test:
+        if each_result[testName]:
+          # If the patch is cached and interesting, prune non-critical fields
+          if testName in each_result and testName in field_change and testName in state.original_field_change:
+              field_change[testName].field_change = {key: value for key, value in field_change[testName].field_change.items() if key in critical_field_list}
+          else:
+            state.logger.debug(f"testName in each_result: {testName in each_result}, "
+                              f"each_result[testName]: {each_result[testName]}, "
+                              f"testName in field_change: {testName in field_change}, "
+                              f"testName in state.original_field_change: {testName in state.original_field_change}")
+    
+    for testName in state.d4j_negative_test:
+      if testName in each_result and testName in field_change and testName in state.original_field_change:
+        # get field difference
+        field_difference_list: list[Tuple[str,float]] = field_change[testName].diff(state.original_field_change[testName]) # list of (field name, field difference)
+
+        if each_result[testName]:
+          # update if the patch is interesting
+          for field_tuple in field_difference_list:
+            print(f'grey-box field alpha updated')
+            field_name:str=field_tuple[0]
+            field_difference=field_tuple[1]
+            
+            # update the critical field data in current node
+            cur_node.critical_field_up_down_manager.update(state,field_name, field_difference)
+      else:
+        state.logger.debug(f"testName in each_result: {testName in each_result}, "
+                          f"each_result[testName]: {each_result[testName]}, "
+                          f"testName in field_change: {testName in field_change}, "
+                          f"testName in state.original_field_change: {testName in state.original_field_change}")
diff --git a/SimAPR/run_test.py b/SimAPR/run_test.py
index 0e18bfe95..1d1563f03 100644
--- a/SimAPR/run_test.py
+++ b/SimAPR/run_test.py
@@ -20,6 +20,7 @@ def run_fail_test_d4j(state: GlobalState, new_env: Dict[str, str]) -> Tuple[bool
         - tuple[1]: run result
         - tuple[2]: is time out
   """
+  
   state.cycle += 1
   state.logger.info(f"@{state.cycle} Run tbar test {new_env['SIMAPR_TEST']} with {new_env['SIMAPR_LOCATION']}")
   args = state.args
diff --git a/SimAPR/select_patch.py b/SimAPR/select_patch.py
index c6ef08bf5..5c011e698 100644
--- a/SimAPR/select_patch.py
+++ b/SimAPR/select_patch.py
@@ -48,11 +48,19 @@ def second_vertical_search_recursion(state:GlobalState, source:PatchTreeNode):
     _source=state
   else:
     _source=source
-  if _source.critical_branch_up_down_manager.is_empty():
+    
+  is_branch_empty = _source.critical_branch_up_down_manager.is_empty()
+  is_field_empty = _source.critical_field_up_down_manager.is_empty()
+  use_field = state.use_field
+
+  if (use_field and is_branch_empty) or (not use_field and is_branch_empty and is_field_empty):
     return epsilon_select(state, source)
 
-  selected_branch:int = random.choice(list(_source.critical_branch_up_down_manager.upDownDict.keys()))
-  isUp:bool=_source.critical_branch_up_down_manager.get_isUp(selected_branch)
+  selected_branch = None if is_branch_empty else random.choice(list(_source.critical_branch_up_down_manager.upDownDict.keys()))
+  isBranchUp = None if is_branch_empty else _source.critical_branch_up_down_manager.get_isUp(selected_branch)
+  
+  selected_field = None if not use_field or is_field_empty else random.choice(list(_source.critical_field_up_down_manager.upDownDict.keys()))
+  isFieldUp = None if not use_field or is_field_empty else _source.critical_field_up_down_manager.get_isUp(selected_field)
 
   state.logger.debug(f"during second vertical search. source: {_source}")
   if source is None:
@@ -60,43 +68,52 @@ def second_vertical_search_recursion(state:GlobalState, source:PatchTreeNode):
     children_map = state.file_info_map
     if state.use_fl_score_in_greybox:
       children_map = filter_children_list_by_fl_score(state, source, children_map)
-    state.logger.debug(f"second vertical traversing on root. file_info_map len: {len(children_map)}, isUp: {isUp}, selected_branch: {selected_branch}")
+    state.logger.debug(f"second vertical traversing on root. file_info_map len: {len(children_map)}, isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
   if isinstance(source, FileInfo):
     children_map = source.func_info_map
     if state.use_fl_score_in_greybox:
       children_map = filter_children_list_by_fl_score(state, source, children_map)
-    state.logger.debug(f"second vertical traversing on file level. func_info_map len: {len(children_map)}, isUp: {isUp}, selected_branch: {selected_branch}")
+    state.logger.debug(f"second vertical traversing on file level. func_info_map len: {len(children_map)}, isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
   elif isinstance(source, FuncInfo):
     children_map = source.line_info_map
     if state.use_fl_score_in_greybox:
       children_map = filter_children_list_by_fl_score(state, source, children_map)
-    state.logger.debug(f"second vertical traversing on func level. line_info_map len: {len(children_map)}, isUp: {isUp}, selected_branch: {selected_branch}")
+    state.logger.debug(f"second vertical traversing on func level. line_info_map len: {len(children_map)}, isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
   elif isinstance(source, LineInfo):
     if state.tool_type == ToolType.TEMPLATE:
       children_map = source.tbar_type_info_map
-      state.logger.debug(f"second vertical traversing on line level. type_info_map len: {len(children_map)}, isUp: {isUp}, selected_branch: {selected_branch}")
+      state.logger.debug(f"second vertical traversing on line level. type_info_map len: {len(children_map)}, isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
     elif state.tool_type == ToolType.LEARNING:
       children_map = source.recoder_case_info_map
-      state.logger.debug(f"second vertical traversing on line level. recoder_case_info_map len: {len(children_map)}, isUp: {isUp}, selected_branch: {selected_branch}")
+      state.logger.debug(f"second vertical traversing on line level. recoder_case_info_map len: {len(children_map)}, isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
   elif isinstance(source, TbarTypeInfo): # Only for Tbar
     children_map = source.tbar_case_info_map
-    state.logger.debug(f"second vertical traversing on type level. case_info_map len: {len(children_map)}, isUp: {isUp}, selected_branch: {selected_branch}")
+    state.logger.debug(f"second vertical traversing on type level. case_info_map len: {len(children_map)}, isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
   elif isinstance(source, TbarCaseInfo): # Only for Tbar
-    state.logger.debug(f"second vertical search done. isUp: {isUp}, selected_branch: {selected_branch}")
+    state.logger.debug(f"second vertical search done. isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
     return source
   elif isinstance(source, RecoderCaseInfo): # Only for Recoder
-    state.logger.debug(f"second vertical search done. isUp: {isUp}, selected_branch: {selected_branch}")
+    state.logger.debug(f"second vertical search done. isBranchUp: {isBranchUp}, selected_branch: {selected_branch}, isFieldUp: {isFieldUp}, selected_field: {selected_field}")
     return source  
 
   randomly_selected_values = []
   for child in children_map.values():
-    randomly_selected_values.append(child.critical_branch_up_down_manager.select_value(selected_branch, isUp))
-
-  _debug=f'Mode of 2nd vertical: {_source}: '
-  for child in children_map.values():
-    _debug+=f'{child.critical_branch_up_down_manager.upDownDict[selected_branch].mode()},'
-  state.logger.debug(_debug)
+    branch_value = 0 if selected_branch == None else child.critical_branch_up_down_manager.select_value(selected_branch, isBranchUp)
+    field_value = 0 if selected_field == None else child.critical_field_up_down_manager.select_value(selected_field, isFieldUp)
+    randomly_selected_values.append(branch_value + field_value)
+
+  if selected_branch != None:
+    _debug=f'Mode of 2nd vertical branch: {_source}: '
+    for child in children_map.values():
+      _debug+=f'{child.critical_branch_up_down_manager.upDownDict[selected_branch].mode()},'
+    state.logger.debug(_debug)
 
+  if selected_field != None:
+    _debug=f'Mode of 2nd vertical field: {_source}: '
+    for child in children_map.values():
+      _debug+=f'{child.critical_field_up_down_manager.upDownDict[selected_field].mode()},'
+    state.logger.debug(_debug)
+    
   _debug=f'Prob of 2nd vertical: {_source}: '
   for i in randomly_selected_values:
     _debug+=f'{i},'
@@ -188,13 +205,14 @@ def epsilon_select(state:GlobalState,source:PatchTreeNode=None):
     else:
       _source=source
 
-    if state.mode == Mode.greybox and not _source.critical_branch_up_down_manager.is_empty() and \
+    can_use_critical_values = (state.use_field == None and not _source.critical_branch_up_down_manager.is_empty()) or (state.use_field != None and (not _source.critical_branch_up_down_manager.is_empty() or not _source.critical_field_up_down_manager.is_empty()))
+    if state.mode == Mode.greybox and can_use_critical_values and \
             ((source is not None and source.children_basic_patches > 0) or (source is None and state.total_basic_patch > 0)):
       state.logger.debug(f"Use second vertical search, epsilon: {epsilon}")
       return second_vertical_search_recursion(state, source)
     # Perform random search in epsilon probability
     else:
-      state.logger.debug(f'is critical_branch empty: {_source.critical_branch_up_down_manager.is_empty()}, is source none: {source is None}')
+      state.logger.debug(f'is critical_branch empty: {_source.critical_branch_up_down_manager.is_empty()}, is critical_field empty: {_source.critical_field_up_down_manager.is_empty()}, is source none: {source is None}')
     state.logger.debug(f'Use epsilon greedy method, epsilon: {epsilon}')
 
     # Choose random element in candidates
diff --git a/SimAPR/simapr.py b/SimAPR/simapr.py
index b0d24fad2..5dabf1771 100755
--- a/SimAPR/simapr.py
+++ b/SimAPR/simapr.py
@@ -37,10 +37,11 @@ def parse_args(argv: list) -> GlobalState:
               'finish-correct-patch','not-count-compile-fail','not-use-guide','not-use-epsilon',
               'finish-top-method','instr-cp=','branch-output=', 'use-fl-score-in-greybox',
               'weight-critical-branch', 'optimized-instrumentation', 'only-get-test-time-data-mode',
-              'test-time-data-location=']
+              'test-time-data-location=', 'field-output=', 'use-field']
   opts, args = getopt.getopt(argv[1:], "ho:w:t:m:c:T:E:k:", longopts)
   state = GlobalState()
   state.critical_branch_up_down_manager = CriticalBranchesUpDownManager(is_this_critical_branches = True)
+  state.critical_field_up_down_manager = CriticalFieldsUpDownManager(is_this_critical_fields = True)
   state.original_args = argv
   state.args = args  # After --
   for o, a in opts:
@@ -158,6 +159,12 @@ def parse_args(argv: list) -> GlobalState:
       state.only_get_test_time_data_mode = True 
     elif o in ['--test-time-data-location']:
       state.test_time_data_location = a
+      
+    # Greybox field stuffs
+    elif o in ['--field-output']:
+      state.field_output = a
+    elif o in ['--use-field']:
+      state.use_field = True
 
   # make output directory if not exists
   if not os.path.exists(state.out_dir):
@@ -170,6 +177,14 @@ def parse_args(argv: list) -> GlobalState:
         os.makedirs(os.path.join(state.out_dir,'branch'))
     elif not os.path.exists(state.branch_output):
       os.makedirs(state.branch_output)
+      
+  # make field output directory if not exists. if the field output directory is not given in arguments, it makes default field output directory.
+  if state.use_simulation_mode:
+    if state.field_output=='':
+      if not os.path.exists(os.path.join(state.out_dir,'field')):
+        os.makedirs(os.path.join(state.out_dir,'field'))
+    elif not os.path.exists(state.field_output):
+      os.makedirs(state.field_output)
   
   # make tmp directory. if the tmp directory already exsists, remove and make it again.
   state.tmp_dir = os.path.join(state.out_dir, 'tmp')
@@ -182,6 +197,12 @@ def parse_args(argv: list) -> GlobalState:
       os.makedirs(state.branch_output)
   elif state.instrumenter_classpath!='':
     state.branch_output=os.path.join(state.out_dir,'branch')
+    
+  if state.field_output!='':
+    if not os.path.exists(state.field_output):
+      os.makedirs(state.field_output)
+  elif state.instrumenter_classpath!='':
+    state.field_output=os.path.join(state.out_dir,'field')
 
   return state
 
diff --git a/SimAPR/simapr_loop.py b/SimAPR/simapr_loop.py
index 987a85a91..242acebe8 100644
--- a/SimAPR/simapr_loop.py
+++ b/SimAPR/simapr_loop.py
@@ -54,7 +54,7 @@ class TBarLoop():
   def save_result(self) -> None:
     result_handler.save_result(self.state)
     
-  def run_test(self, patch: TbarPatchInfo, test: str, get_branch_cov:bool=False) -> Tuple[bool, bool,float,branch_coverage.BranchCoverage]:
+  def run_test(self, patch: TbarPatchInfo, test: str, get_greybox_info:bool=False) -> Tuple[bool, bool,float,branch_coverage.BranchCoverage, field_change.FieldChange]:
     """
     TODO: need more description
     _summary_
@@ -66,20 +66,21 @@ class TBarLoop():
     Returns:
         Tuple[bool, bool,float,branch_coverage.BranchCoverage]: _description_
     """
-    cur_cov=None
+    cur_info=None
+    field_info=None
     new_env=EnvGenerator.get_new_env_tbar(self.state, patch, test)
     start_time=time.time()
     compilable, run_result, is_timeout = run_test.run_fail_test_d4j(self.state, new_env)
     run_time=time.time()-start_time
     
-    if self.state.mode == Mode.greybox and (run_result or get_branch_cov):
+    if self.state.mode == Mode.greybox and (run_result or get_greybox_info):
       if not self.state.only_get_test_time_data_mode:
         new_env=EnvGenerator.get_new_env_tbar(self.state, patch, test,instrument=True)
         self.state.logger.info("Running the test again with full instrumentation.")
         _, _, _ = run_test.run_fail_test_d4j(self.state, new_env)
 
       try:
-        cur_cov=branch_coverage.parse_cov(self.state.logger,new_env['GREYBOX_RESULT'])
+        cur_info=branch_coverage.parse_cov(self.state.logger,new_env['GREYBOX_RESULT'])
         dest_file_name = os.path.join(self.state.branch_output,f'{patch.tbar_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
         self.state.logger.info(f"branch dest: {dest_file_name}")
         os.makedirs(os.path.dirname(dest_file_name), exist_ok=True)
@@ -87,11 +88,26 @@ class TBarLoop():
         os.remove(new_env['GREYBOX_RESULT'])
         
         if patch.tbar_case_info.location=='original':
-          self.state.original_branch_cov[test]=cur_cov
+          self.state.original_branch_cov[test]=cur_info
+        
       except OSError as e:
         self.state.logger.warning(f"Greybox result not found for {patch.tbar_case_info.location} {test}. expected location: {new_env['GREYBOX_RESULT']}")
         
-    return compilable, run_result, run_time, cur_cov
+      try:
+        field_info=field_change.parse_change(self.state.logger,new_env['GREYBOX_FIELD_RESULT'])
+        dest_file_name = os.path.join(self.state.field_output,f'{patch.tbar_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
+        self.state.logger.info(f"field dest: {dest_file_name}")
+        os.makedirs(os.path.dirname(dest_file_name), exist_ok=True)
+        shutil.copyfile(new_env['GREYBOX_FIELD_RESULT'],dest_file_name)
+        os.remove(new_env['GREYBOX_FIELD_RESULT'])
+        
+        if patch.tbar_case_info.location=='original':
+          self.state.original_field_change[test]=field_info
+          
+      except OSError as e:
+        self.state.logger.warning(f"Greybox result not found for {patch.tbar_case_info.location} {test}. expected location: {new_env['GREYBOX_FIELD_RESULT']}")
+        
+    return compilable, run_result, run_time, cur_info, field_info
       
   def run_test_positive(self, patch: TbarPatchInfo) -> Tuple[bool,float]:
     start_time=time.time()
@@ -109,7 +125,7 @@ class TBarLoop():
       if neg in self.state.failed_positive_test:
         self.state.d4j_negative_test.remove(neg)
       else:
-        compilable, run_result,_,_ = self.run_test(op, neg,get_branch_cov=True)
+        compilable, run_result,_,_,_ = self.run_test(op, neg,get_greybox_info=True)
         if not compilable:
           self.state.logger.warning("Project is not compilable")
           self.state.is_alive = False
@@ -168,10 +184,11 @@ class TBarLoop():
       is_compilable = True
       pass_time=0
       coverages:Dict[str,branch_coverage.BranchCoverage]=dict() # key: test name, value: branch coverage(contains a dict that shows how many times each branch has been taken.)
+      changes:Dict[str,field_change.FieldChange]=dict() # key: test name, value: field change(contains a dict that shows the changes of the field value.)
       self.state.new_critical_list = []
       
       for neg in self.state.d4j_negative_test:
-        compilable, run_result,fail_time,cur_cov = self.run_test(patch, neg)
+        compilable, run_result,fail_time,cur_cov, cur_change = self.run_test(patch, neg)
         
         if not compilable:
           is_compilable = False
@@ -192,6 +209,10 @@ class TBarLoop():
         if cur_cov is not None:
           self.state.logger.debug(f"coverages neg name: {neg}")
           coverages[neg]=cur_cov
+
+        if cur_change is not None:
+          self.state.logger.debug(f"changes neg name: {neg}")
+          changes[neg]=cur_change
           
         self.state.test_time+=fail_time
         
@@ -212,6 +233,7 @@ class TBarLoop():
           # well never mind. the function below doesn't even use the pass_result.
         self.state.logger.debug("result handler is called")
         result_handler.update_result_branch(self.state,patch,coverages,is_compilable,each_result,pass_result)
+        result_handler.update_result_field(self.state,patch,changes,is_compilable,each_result,pass_result)
 
       if is_compilable or self.state.ignore_compile_error:
         result_handler.update_result_tbar(self.state, patch, pass_exists)
@@ -246,8 +268,9 @@ class TBarLoop():
       if key not in self.state.simulation_data or 'fail_time' not in self.state.simulation_data[key]:
         each_result=dict()
         coverages:Dict[str,branch_coverage.BranchCoverage]=dict()
+        changes:Dict[str,field_change.FieldChange]=dict()
         for neg in self.state.d4j_negative_test:
-          compilable, run_result,fail_time,cur_cov = self.run_test(patch, neg)
+          compilable, run_result, fail_time, cur_cov, cur_change = self.run_test(patch, neg)
           self.state.test_time+=fail_time
           if not compilable:
             is_compilable = False
@@ -263,13 +286,16 @@ class TBarLoop():
             each_result[neg]=True
           if cur_cov is not None:
             coverages[neg]=cur_cov
+          if cur_change is not None:
+            changes[neg]=cur_change
 
-        #add an entry that maps this patch to its branchess
+        #add an entry that maps this patch to its branches
         if is_compilable:
           self.state.visited_tbar_patch.append(patch.tbar_case_info.location)
           self.state.patch_to_branches_map[patch.tbar_case_info.location] = []
         if self.state.mode==Mode.greybox:
           result_handler.update_result_branch(self.state,patch,coverages,is_compilable,each_result,pass_result)
+          result_handler.update_result_field(self.state,patch,changes,is_compilable,each_result,pass_result)
 
         if is_compilable or self.state.ignore_compile_error:
           result_handler.update_result_tbar(self.state, patch, pass_exists)
@@ -300,19 +326,30 @@ class TBarLoop():
 
         if self.state.mode==Mode.greybox:
           coverages:Dict[str,branch_coverage.BranchCoverage]=dict()
+          changes:Dict[str,field_change.FieldChange]=dict()
+          
           if is_compilable:
             for test in each_result.keys():
               cov_file=os.path.join(self.state.branch_output,
                                     f'{patch.tbar_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
-              if not os.path.exists(cov_file) and not greybox_done:
+              change_file=os.path.join(self.state.field_output,
+                                    f'{patch.tbar_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
+              if not os.path.exists(cov_file) and not greybox_done or not os.path.exists(change_file):
                 # Retry if greybox not done yet
-                compilable, run_result,fail_time,cur_cov = self.run_test(patch, test,get_branch_cov=True)
+                compilable, run_result,fail_time,cur_cov, cur_change = self.run_test(patch, test,get_greybox_info=True)
               if os.path.exists(cov_file):
                 cur_cov=branch_coverage.parse_cov(self.state.logger,cov_file)
                 coverages[test]=cur_cov
               else:
                 self.state.logger.warning(f"Greybox result not found for {patch.tbar_case_info.location} {test}. expected location: {cov_file}")
+              if os.path.exists(change_file):
+                cur_change=field_change.parse_change(self.state.logger,change_file)
+                changes[test]=cur_change
+              else:
+                self.state.logger.warning(f"Greybox result not found for {patch.tbar_case_info.location} {test}. expected location: {change_file}")
+                
           result_handler.update_result_branch(self.state,patch,coverages,is_compilable,each_result,pass_result)
+          result_handler.update_result_field(self.state,patch,changes,is_compilable,each_result,pass_result)
 
         if is_compilable or self.state.ignore_compile_error:
           result_handler.update_result_tbar(self.state, patch, pass_exists)
@@ -349,7 +386,7 @@ class TBarLoop():
               test_time_data[self.state.mode.name][patch] = {}
               for neg in self.state.d4j_negative_test:
                 self.state.logger.info("run test: "+ neg)
-                compilable, run_result,fail_time,cur_cov = self.run_test(TbarPatchInfo(case_info), neg)
+                compilable, run_result,fail_time,cur_cov, cur_change = self.run_test(TbarPatchInfo(case_info), neg)
                 test_time_data[self.state.mode.name][patch][neg] = fail_time
               break
           if found_patch:
@@ -387,21 +424,22 @@ class RecoderLoop(TBarLoop):
       self.state.is_alive=False
     return self.state.is_alive
   
-  def run_test(self, patch: RecoderPatchInfo, test: str, get_branch_cov:bool=False) -> Tuple[bool, bool, float, branch_coverage.BranchCoverage]:
-    cur_cov=None
+  def run_test(self, patch: RecoderPatchInfo, test: str, get_greybox_info:bool=False) -> Tuple[bool, bool, float, branch_coverage.BranchCoverage, field_change.FieldChange]:
+    branch_info=None
+    field_info=None
     new_env=EnvGenerator.get_new_env_recoder(self.state, patch, test)
     start_time=time.time()
     compilable, run_result, is_timeout = run_test.run_fail_test_d4j(self.state, new_env)
     run_time=time.time()-start_time
     
-    if self.state.mode == Mode.greybox and (run_result or get_branch_cov):
+    if self.state.mode == Mode.greybox and (run_result or get_greybox_info):
       if not self.state.only_get_test_time_data_mode:
         new_env=EnvGenerator.get_new_env_recoder(self.state, patch, test,instrument=True)
         self.state.logger.info("Running the test again with full instrumentation.")
         _, _, _ = run_test.run_fail_test_d4j(self.state, new_env)
 
       try:
-        cur_cov=branch_coverage.parse_cov(self.state.logger,new_env['GREYBOX_RESULT'])
+        branch_info=branch_coverage.parse_cov(self.state.logger,new_env['GREYBOX_RESULT'])
         self.state.logger.info("everything is fine")
         dest_file_name = os.path.join(self.state.branch_output,f'{patch.recoder_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
         os.makedirs(os.path.dirname(dest_file_name), exist_ok=True)
@@ -409,12 +447,26 @@ class RecoderLoop(TBarLoop):
         os.remove(new_env['GREYBOX_RESULT'])
 
         if patch.recoder_case_info.location=='original':
-          self.state.original_branch_cov[test]=cur_cov
+          self.state.original_branch_cov[test]=branch_info
       except OSError as e:
         self.state.logger.error(e)
         self.state.logger.warning(f"Greybox result not found for {patch.recoder_case_info.location} {test}. expected location: {new_env['GREYBOX_RESULT']}")
 
-    return compilable, run_result,run_time,cur_cov
+      try:
+        field_info=field_change.parse_change(self.state.logger,new_env['GREYBOX_FIELD_RESULT'])
+        dest_file_name = os.path.join(self.state.field_output,f'{patch.recoder_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
+        self.state.logger.info(f"field dest: {dest_file_name}")
+        os.makedirs(os.path.dirname(dest_file_name), exist_ok=True)
+        shutil.copyfile(new_env['GREYBOX_FIELD_RESULT'],dest_file_name)
+        os.remove(new_env['GREYBOX_FIELD_RESULT'])
+        
+        if patch.recoder_case_info.location=='original':
+          self.state.original_field_change[test]=field_info
+          
+      except OSError as e:
+        self.state.logger.warning(f"Greybox result not found for {patch.recoder_case_info.location} {test}. expected location: {new_env['GREYBOX_FIELD_RESULT']}")
+
+    return compilable, run_result,run_time,branch_info,field_info
   
   def run_test_positive(self, patch: RecoderPatchInfo) -> Tuple[bool,float]:
     start_time=time.time()
@@ -428,7 +480,7 @@ class RecoderLoop(TBarLoop):
     original = self.state.patch_location_map["original"]
     op = RecoderPatchInfo(original)
     for neg in self.state.d4j_negative_test.copy():
-      compilable, run_result,_,_ = self.run_test(op, neg,get_branch_cov=True)
+      compilable, run_result,_,_,_ = self.run_test(op, neg,get_greybox_info=True)
       if not compilable:
         self.state.logger.warning("Project is not compilable")
         self.state.is_alive = False
@@ -475,9 +527,11 @@ class RecoderLoop(TBarLoop):
       pass_time=0
       each_result=dict()
       coverages:Dict[str,branch_coverage.BranchCoverage]=dict()
+      changes:Dict[str,field_change.FieldChange]=dict()
       self.state.new_critical_list = []
+      
       for neg in self.state.d4j_negative_test:
-        compilable, run_result,fail_time,cur_cov = self.run_test(patch, neg)
+        compilable, run_result,fail_time,cur_cov,cur_change = self.run_test(patch, neg)
         self.state.test_time+=fail_time
         if not compilable:
           is_compilable = False
@@ -494,12 +548,16 @@ class RecoderLoop(TBarLoop):
 
         if cur_cov is not None:
           coverages[neg]=cur_cov
+        
+        if cur_change is not None:
+          changes[neg]=cur_change
 
       if is_compilable:
         self.state.visited_tbar_patch.append(patch.recoder_case_info.location)
         self.state.patch_to_branches_map[patch.recoder_case_info.location] = []
       if self.state.mode==Mode.greybox:
         result_handler.update_result_branch(self.state,patch,coverages,is_compilable,each_result,pass_result)
+        result_handler.update_result_field(self.state,patch,changes,is_compilable,each_result,pass_result)
 
       if is_compilable or self.state.count_compile_fail:
         self.state.iteration += 1
@@ -514,7 +572,7 @@ class RecoderLoop(TBarLoop):
 
   def run_sim(self) -> None:
     self.state.start_time = time.time()
-    self.state.cycle = 0    
+    self.state.cycle = 0
     
     while(self.is_alive()):
       self.state.logger.info(f'[{self.state.cycle}]: executing')
@@ -535,8 +593,9 @@ class RecoderLoop(TBarLoop):
         
         each_result=dict()
         coverages:Dict[str,branch_coverage.BranchCoverage]=dict()
+        changes:Dict[str,field_change.FieldChange]=dict()
         for neg in self.state.d4j_negative_test:
-          compilable, run_result,fail_time,cur_cov = self.run_test(patch, neg)
+          compilable, run_result,fail_time,cur_cov,cur_change = self.run_test(patch, neg)
           self.state.test_time+=fail_time
           if not compilable:
             is_compilable = False
@@ -553,14 +612,18 @@ class RecoderLoop(TBarLoop):
 
           if cur_cov is not None:
             coverages[neg]=cur_cov
+          
+          if cur_change is not None:
+            changes[neg]=cur_change
 
-        #add an entry that maps this patch to its branchess
+        #add an entry that maps this patch to its branches and fields
         if is_compilable:
           self.state.visited_tbar_patch.append(patch.recoder_case_info.location)
           self.state.patch_to_branches_map[patch.recoder_case_info.location] = []
         if self.state.mode==Mode.greybox:
           result_handler.update_result_branch(self.state,patch,coverages,is_compilable,each_result,pass_result)
-
+          result_handler.update_result_field(self.state,patch,changes,is_compilable,each_result,pass_result)
+        
         if is_compilable or self.state.ignore_compile_error:
           result_handler.update_result_recoder(self.state, patch, pass_exists)
           if result and self.state.use_pass_test:
@@ -580,27 +643,37 @@ class RecoderLoop(TBarLoop):
         is_compilable=simapr_result['compilable']
         greybox_done=simapr_result['done_greybox'] if 'done_greybox' in simapr_result else False
 
-        #add an entry that maps this patch to its branchess
+        #add an entry that maps this patch to its branches and fields
         if is_compilable:
           self.state.visited_tbar_patch.append(patch.recoder_case_info.location)
           self.state.patch_to_branches_map[patch.recoder_case_info.location] = []
 
         if self.state.mode==Mode.greybox:
           coverages:Dict[str,branch_coverage.BranchCoverage]=dict()
+          changes:Dict[str,field_change.FieldChange]=dict()
+          
           if is_compilable:
             for test in each_result.keys():
               if each_result[test]:
                 cov_file=os.path.join(self.state.branch_output,
                                       f'{patch.recoder_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
-                if not os.path.exists(cov_file) and not greybox_done:
+                change_file=os.path.join(self.state.field_output,
+                                    f'{patch.recoder_case_info.location.replace("/","#")}_{test.split(".")[-2]}.{test.split(".")[-1]}.txt')
+                if not greybox_done and not (os.path.exists(cov_file) and os.path.exists(change_file)):
                   # Retry if greybox not done yet
-                  compilable, run_result,fail_time,cur_cov = self.run_test(patch, test,get_branch_cov=True)
+                  compilable, run_result,fail_time,cur_cov,cur_change = self.run_test(patch, test,get_greybox_info=True)
                 if os.path.exists(cov_file):
                   cur_cov=branch_coverage.parse_cov(self.state.logger,cov_file)
                   coverages[test]=cur_cov
                 else:
                   self.state.logger.warning(f"Greybox result not found for {patch.recoder_case_info.location} {test}. expected location: {cov_file}")
+                if os.path.exists(change_file):
+                  cur_change=field_change.parse_change(self.state.logger,change_file)
+                  changes[test]=cur_change
+                else:
+                  self.state.logger.warning(f"Greybox result not found for {patch.recoder_case_info.location} {test}. expected location: {change_file}")
           result_handler.update_result_branch(self.state,patch,coverages,is_compilable,each_result,pass_result)
+          result_handler.update_result_field(self.state,patch,changes,is_compilable,each_result,pass_result)
 
         if is_compilable or self.state.ignore_compile_error:
           result_handler.update_result_recoder(self.state, patch, pass_exists)
@@ -637,7 +710,7 @@ class RecoderLoop(TBarLoop):
               test_time_data[self.state.mode.name][patch] = {}
               for neg in self.state.d4j_negative_test:
                 self.state.logger.info("run test: "+ neg)
-                compilable, run_result,fail_time,cur_cov = self.run_test(RecoderPatchInfo(case_info), neg)
+                compilable, run_result,fail_time,cur_cov,cur_change = self.run_test(RecoderPatchInfo(case_info), neg)
                 test_time_data[self.state.mode.name][patch][neg] = fail_time
               break
           if found_patch:
diff --git a/experiments/scripts/rq1-iteration.py b/experiments/scripts/rq1-iteration.py
index 755ef0e0f..8aca2f22b 100644
--- a/experiments/scripts/rq1-iteration.py
+++ b/experiments/scripts/rq1-iteration.py
@@ -11,14 +11,18 @@ from getopt import getopt
 
 import d4j
 
-MAX_EXP=10
+MAX_EXP=3
 WITH_MOCKITO=False
 MAX_ITERATION=3000
 
+# excepts = ['Closure_126']
+excepts = []
+
 def plot_patches_ci_java(mode='tbar'):
     orig_result:List[int]=[]
     casino_result:List[List[int]]=[]
     greybox_result:List[List[int]]=[]
+    greyboxfd_result:List[List[int]]=[]
 
     valid_patch_set:Dict[str,set]=dict()
 
@@ -26,7 +30,9 @@ def plot_patches_ci_java(mode='tbar'):
     for i in range(MAX_EXP):
         casino_result.append([])
         for result in d4j.D4J_1_2_LIST:
-            if not path.exists(f'{mode}/result/{result}-greybox-{MAX_EXP-1}/simapr-finished.txt'):
+            if result in excepts:
+                continue
+            if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
                 # Skip if experiment not end
                 continue
             if not WITH_MOCKITO and 'Mockito' in result:
@@ -37,7 +43,7 @@ def plot_patches_ci_java(mode='tbar'):
                 continue
             root=json.load(result_file)
             result_file.close()
-
+            
             if result not in valid_patch_set:
                 valid_patch_set[result]=set()
             for res in root:
@@ -60,7 +66,9 @@ def plot_patches_ci_java(mode='tbar'):
     for i in range(MAX_EXP):
         greybox_result.append([])
         for result in d4j.D4J_1_2_LIST:
-            if not path.exists(f'{mode}/result/{result}-greybox-{MAX_EXP-1}/simapr-finished.txt'):
+            if result in excepts:
+                continue
+            if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
                 # Skip if experiment not end
                 continue
             if not WITH_MOCKITO and 'Mockito' in result:
@@ -89,10 +97,48 @@ def plot_patches_ci_java(mode='tbar'):
                     break
 
     print(np.mean([len(l) for l in greybox_result]))
+    
+    # Greybox with critical field
+    for i in range(MAX_EXP):
+        greyboxfd_result.append([])
+        for result in d4j.D4J_1_2_LIST:
+            if result in excepts:
+                continue
+            if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
+                # Skip if experiment not end
+                continue
+            if not WITH_MOCKITO and 'Mockito' in result:
+                continue
+            try:
+                result_file=open(f'{mode}/result/{result}-greyboxfd-{i}/simapr-result.json','r')
+            except:
+                continue
+            root=json.load(result_file)
+            result_file.close()
+
+            if result not in valid_patch_set:
+                valid_patch_set[result]=set()
+            for res in root:
+                is_hq=res['result']
+                is_plausible=res['pass_result']
+                iteration=res['iteration']
+                time=res['time']
+                loc=res['config'][0]['location']
+
+                if is_plausible:
+                    valid_patch_set[result].add(loc)
+                    greyboxfd_result[-1].append(iteration)
+
+                if iteration>MAX_ITERATION:
+                    break
+
+    print(np.mean([len(l) for l in greyboxfd_result]))
 
     # Original
     for result in d4j.D4J_1_2_LIST:
-        if not path.exists(f'{mode}/result/{result}-greybox-{MAX_EXP-1}/simapr-finished.txt'):
+        if result in excepts:
+            continue
+        if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
             # Skip if experiment not end
             continue
         if not WITH_MOCKITO and 'Mockito' in result:
@@ -207,6 +253,32 @@ def plot_patches_ci_java(mode='tbar'):
                     guided_y.append(guided_y[-1])
     guided_df=pd.DataFrame({'Time':guided_x,'Number of valid patches':guided_y})
     seaborn.lineplot(data=guided_df,x='Time',y='Number of valid patches',color='r',label='Gresino',linestyle='dashed')
+    
+    # Greybox with critical field
+    guided_list:List[List[int]]=[]
+    guided_x=[]
+    guided_y=[]
+    temp_=[[],[],[],[],[],[]]
+    for j in range(MAX_EXP):
+        cur_result=sorted(greyboxfd_result[j])
+        guided_list.append([0])
+        for i in range(0,MAX_ITERATION+1):
+            if i in cur_result:
+                guided_list[-1].append(guided_list[-1][-1]+cur_result.count(i)/MAX_EXP)
+                guided_x.append(i)
+                if i==0:
+                    guided_y.append(0)
+                else:
+                    guided_y.append(guided_y[-1]+cur_result.count(i))
+            else:
+                guided_list[-1].append(guided_list[-1][-1])
+                guided_x.append(i)
+                if i==0:
+                    guided_y.append(0)
+                else:
+                    guided_y.append(guided_y[-1])
+    guided_df=pd.DataFrame({'Time':guided_x,'Number of valid patches':guided_y})
+    seaborn.lineplot(data=guided_df,x='Time',y='Number of valid patches',color='y',label='Gresino + field',linestyle='dotted')
 
     plt.legend(fontsize=12)
     plt.xlabel('Iteration',fontsize=15)
@@ -227,5 +299,5 @@ if __name__=='__main__':
     for opt,arg in o:
         if o=='--with-mockito':
             WITH_MOCKITO=True
-
+    
     plot_patches_ci_java(a[0])
\ No newline at end of file
diff --git a/experiments/scripts/rq1-time.py b/experiments/scripts/rq1-time.py
index e5595938d..9b87ae6d3 100644
--- a/experiments/scripts/rq1-time.py
+++ b/experiments/scripts/rq1-time.py
@@ -12,7 +12,7 @@ from getopt import getopt
 
 import d4j
 
-MAX_EXP=10
+MAX_EXP=3
 WITH_MOCKITO=False
 MAX_TIME=300
 
@@ -21,6 +21,7 @@ def plot_patches_ci_java(mode='tbar'):
     orig_result:List[int]=[]
     casino_result:List[List[int]]=[]
     greybox_result:List[List[int]]=[]
+    greyboxfd_result:List[List[int]]=[]
 
     valid_patch_set:Dict[str,set]=dict()
 
@@ -28,7 +29,7 @@ def plot_patches_ci_java(mode='tbar'):
     for i in range(MAX_EXP):
         casino_result.append([])
         for result in d4j.D4J_1_2_LIST:
-            if not path.exists(f'{mode}/result/{result}-greybox-{MAX_EXP-1}/simapr-finished.txt'):
+            if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
                 # Skip if experiment not end
                 continue
             if not WITH_MOCKITO and 'Mockito' in result:
@@ -74,7 +75,7 @@ def plot_patches_ci_java(mode='tbar'):
 
     # Original
     for result in d4j.D4J_1_2_LIST:
-        if not path.exists(f'{mode}/result/{result}-greybox-{MAX_EXP-1}/simapr-finished.txt'):
+        if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
             # Skip if experiment not end
             continue
         if not WITH_MOCKITO and 'Mockito' in result:
@@ -122,7 +123,7 @@ def plot_patches_ci_java(mode='tbar'):
     for i in range(MAX_EXP):
         greybox_result.append([])
         for result in d4j.D4J_1_2_LIST:
-            if not path.exists(f'{mode}/result/{result}-greybox-{MAX_EXP-1}/simapr-finished.txt'):
+            if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
                 # Skip if experiment not end
                 continue
             if not WITH_MOCKITO and 'Mockito' in result:
@@ -176,6 +177,65 @@ def plot_patches_ci_java(mode='tbar'):
                     greybox_result[-1].append(round((total_time)/60))
 
     print(np.mean([len(l) for l in greybox_result]))
+    
+    # Greybox with critical field
+    for i in range(MAX_EXP):
+        greyboxfd_result.append([])
+        for result in d4j.D4J_1_2_LIST:
+            if not path.exists(f'{mode}/result/{result}-greyboxfd-{MAX_EXP-1}/simapr-finished.txt'):
+                # Skip if experiment not end
+                continue
+            if not WITH_MOCKITO and 'Mockito' in result:
+                continue
+            try:
+                result_file=open(f'{mode}/result/{result}-greyboxfd-{i}/simapr-result.json','r')
+            except:
+                continue
+            root=json.load(result_file)
+            result_file.close()
+
+            if result not in valid_patch_set:
+                valid_patch_set[result]=set()
+
+            # Read cache to get baseline time
+            try:
+                cache_file=open(f'{mode}/result/cache/{result}-cache.json','r')
+            except:
+                continue
+            cache=json.load(cache_file)
+            cache_file.close()
+
+            file_instrument_time:Dict[str,float]=dict()
+            with open(f'scripts/file-instrument-time/{result}.txt','r') as f:
+                for line in f:
+                    file,time=line.strip().split(',')
+                    file_instrument_time[file]=float(time)
+
+            total_time=0.
+            fail_time_list=[]
+            for res in root:
+                is_hq=res['result']
+                is_plausible=res['pass_result']
+                iteration=res['iteration']
+                loc=res['config'][0]['location']
+                if loc not in cache:
+                    total_time+=mean(fail_time_list)
+                elif 'fail_time' in cache[loc]:
+                    total_time+=cache[loc]['fail_time']+cache[loc]['pass_time']
+                    fail_time_list.append(cache[loc]['fail_time'])
+                else:
+                    total_time+=mean(fail_time_list)+cache[loc]['pass_time']
+                if is_hq:
+                    # Instrumentation time
+                    total_time+=file_instrument_time[loc.split('/')[-1]]
+
+                if is_plausible:
+                    if MAX_TIME<round((total_time)/60):
+                        MAX_TIME=round((total_time)/60)
+                    valid_patch_set[result].add(loc)
+                    greyboxfd_result[-1].append(round((total_time)/60))
+
+    print(np.mean([len(l) for l in greyboxfd_result]))
 
     # Store valid patch set to csv file
     if WITH_MOCKITO:
@@ -261,6 +321,31 @@ def plot_patches_ci_java(mode='tbar'):
                     other_y.append(other_y[-1])
     other_df=pd.DataFrame({'Time':other_x,'Number of valid patches':other_y})
     seaborn.lineplot(data=other_df,x='Time',y='Number of valid patches',color='r',label='Gresino',linestyle='dashed')
+    
+    # Greybox with critical field
+    other_list:List[List[int]]=[]
+    other_x=[]
+    other_y=[]
+    for j in range(MAX_EXP):
+        cur_result=sorted(greyboxfd_result[j])
+        other_list.append([0])
+        for i in range(0,MAX_TIME+1):
+            if i in cur_result:
+                other_list[-1].append(other_list[-1][-1]+cur_result.count(i)/MAX_EXP)
+                other_x.append(i)
+                if i==0:
+                    other_y.append(0)
+                else:
+                    other_y.append(other_y[-1]+cur_result.count(i))
+            else:
+                other_list[-1].append(other_list[-1][-1])
+                other_x.append(i)
+                if i==0:
+                    other_y.append(0)
+                else:
+                    other_y.append(other_y[-1])
+    other_df=pd.DataFrame({'Time':other_x,'Number of valid patches':other_y})
+    seaborn.lineplot(data=other_df,x='Time',y='Number of valid patches',color='y',label='Gresino + field',linestyle='dotted')
 
     plt.legend(fontsize=12)
     plt.xlabel('Time (min)',fontsize=15)
diff --git a/experiments/tbar/core b/experiments/tbar/core
new file mode 100644
index 000000000..a9948955b
Binary files /dev/null and b/experiments/tbar/core differ
diff --git a/experiments/tbar/search-tbar-greybox.py b/experiments/tbar/search-tbar-greybox.py
index 7db8733eb..6e4ca0b8c 100644
--- a/experiments/tbar/search-tbar-greybox.py
+++ b/experiments/tbar/search-tbar-greybox.py
@@ -18,7 +18,7 @@ def run(project,seed,trial):
     result=subprocess.run(['python3',f'{new_cur_dir}/SimAPR/simapr.py','-o',f'result/{project}-greybox-{trial}','-m','greybox',
                            '--seed',f'{seed}','-k','template','-w',f'{new_cur_dir}/TBar/d4j/{project}','-t','180000',
                            '--use-simulation-mode',f'result/cache/{project}-cache.json','--instr-cp','../../../JPatchInst','--debug',
-                           '--branch-output',f'result/branch/{project}','-E','3000','--skip-valid','--optimized-instrumentation',
+                           '--branch-output',f'result/branch/{project}', '--field-output',f'result/field/{project}', '-E','3000','--skip-valid','--optimized-instrumentation',
                            '--','python3',f'{new_cur_dir}/SimAPR/script/d4j_run_test.py',f'{new_cur_dir}/TBar/buggy'])
     
     print(f'{project} greybox-{trial} finish with return code {result.returncode}')
diff --git a/experiments/tbar/search-tbar-greyboxfd.py b/experiments/tbar/search-tbar-greyboxfd.py
new file mode 100644
index 000000000..7a8dd1306
--- /dev/null
+++ b/experiments/tbar/search-tbar-greyboxfd.py
@@ -0,0 +1,33 @@
+import os
+import sys
+import subprocess
+
+
+def run(project,seed,trial):
+    cur_dir=os.getcwd()
+    if not cur_dir.endswith('experiments/tbar'):
+        print('Please run this script in experiments/tbar',file=sys.stderr)
+        sys.exit(1)
+
+    cur_dirs=cur_dir.split('/')
+    new_cur_dir=''
+    for dir in cur_dirs[:-2]:
+        new_cur_dir+=dir+'/'
+
+    print(f"Run {project}-greybox-{trial}")
+    result=subprocess.run(['python3',f'{new_cur_dir}/SimAPR/simapr.py','-o',f'result/{project}-greyboxfd-{trial}','-m','greybox',
+                           '--seed',f'{seed}','-k','template','-w',f'{new_cur_dir}/TBar/d4j/{project}','-t','180000',
+                           '--use-simulation-mode',f'result/cache/{project}-cache.json','--instr-cp','../../../JPatchInst','--debug',
+                           '--branch-output',f'result/branch/{project}', '--field-output',f'result/field/{project}', '--use-field', '-E','3000','--skip-valid','--optimized-instrumentation',
+                           '--','python3',f'{new_cur_dir}/SimAPR/script/d4j_run_test.py',f'{new_cur_dir}/TBar/buggy'])
+    
+    print(f'{project} greybox-{trial} finish with return code {result.returncode}')
+    exit(result.returncode)
+
+if __name__ == '__main__':
+    args=sys.argv
+    if len(args)!=4:
+        print('Usage: python3 search-tbar-greybox.py <project> <seed> <trial>')
+        sys.exit(1)
+    
+    run(args[1],args[2],args[3])
\ No newline at end of file
diff --git a/experiments/tbar/search.py b/experiments/tbar/search.py
index 9caa0b3d9..65b7ae22c 100644
--- a/experiments/tbar/search.py
+++ b/experiments/tbar/search.py
@@ -3,6 +3,8 @@ import subprocess
 import multiprocessing as mp
 import seeds
 
+TRY_COUNT = 3
+
 def run(project):
    print(f'Run {project}-orig')
    result=subprocess.run(['python3','search-tbar-orig.py',project],stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
@@ -10,7 +12,7 @@ def run(project):
       f.write(result.stdout.decode("utf-8"))
    print(f'Finish {project}-orig with returncode {result.returncode}')
 
-   for i in range(10):
+   for i in range(TRY_COUNT):
       print(f'Run {project}-casino-{i}')
       result=subprocess.run(['python3','search-tbar-casino.py',project,str(seeds.SEEDS[i]),str(i)],
                             stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
@@ -24,6 +26,13 @@ def run(project):
       with open(f'result/{project}-greybox-{i}.log','w') as f:
          f.write(result.stdout.decode("utf-8"))
       print(f'Finish {project}-greybox-{i} with returncode {result.returncode}')
+      
+      print(f'Run {project}-greyboxfd-{i}')
+      result=subprocess.run(['python3','search-tbar-greyboxfd.py',project,str(seeds.SEEDS[i]),str(i)],
+                            stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
+      with open(f'result/{project}-greyboxfd-{i}.log','w') as f:
+         f.write(result.stdout.decode("utf-8"))
+      print(f'Finish {project}-greyboxfd-{i} with returncode {result.returncode}')
 
 from sys import argv